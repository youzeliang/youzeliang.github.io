<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>golang 切片 - 梁友泽的博客</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="梁友泽的博客"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="梁友泽的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="切片结构12345type slice struct &amp;#123;	array unsafe.Pointer	len   int	cap   int&amp;#125;  12a &amp;#x3D; make([]int, 0)unsafe.Sizeof(a)	&amp;#x2F;&amp;#x2F; 24  切片组成元素：  指针：指向底层数组 长度：切片中元素的长度，不能大于容量 容量：指针所指向的底层数组的总容量"><meta property="og:type" content="blog"><meta property="og:title" content="golang 切片"><meta property="og:url" content="https://www.liangyouze.com/2020/10/11/golang%E5%88%87%E7%89%87/"><meta property="og:site_name" content="梁友泽的博客"><meta property="og:description" content="切片结构12345type slice struct &amp;#123;	array unsafe.Pointer	len   int	cap   int&amp;#125;  12a &amp;#x3D; make([]int, 0)unsafe.Sizeof(a)	&amp;#x2F;&amp;#x2F; 24  切片组成元素：  指针：指向底层数组 长度：切片中元素的长度，不能大于容量 容量：指针所指向的底层数组的总容量"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://www.liangyouze.com/img/images/go/%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9.png"><meta property="og:image" content="https://www.liangyouze.com/img/images/go/image1.png"><meta property="og:image" content="https://www.liangyouze.com/img/images/go/image2.png"><meta property="og:image" content="https://www.liangyouze.com/img/images/go/image3.png"><meta property="article:published_time" content="2020-10-11T07:10:23.000Z"><meta property="article:modified_time" content="2025-01-02T13:37:12.450Z"><meta property="article:author" content="梁友泽"><meta property="article:tag" content="golang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://www.liangyouze.com/img/images/go/%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.liangyouze.com/2020/10/11/golang%E5%88%87%E7%89%87/"},"headline":"golang 切片","image":["https://www.liangyouze.com/img/images/go/%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9.png","https://www.liangyouze.com/img/images/go/image1.png","https://www.liangyouze.com/img/images/go/image2.png","https://www.liangyouze.com/img/images/go/image3.png"],"datePublished":"2020-10-11T07:10:23.000Z","dateModified":"2025-01-02T13:37:12.450Z","author":{"@type":"Person","name":"梁友泽"},"publisher":{"@type":"Organization","name":"梁友泽的博客","logo":{"@type":"ImageObject","url":"https://www.liangyouze.com/img/logo.svg"}},"description":"切片结构12345type slice struct &#123;\tarray unsafe.Pointer\tlen   int\tcap   int&#125;  12a &#x3D; make([]int, 0)unsafe.Sizeof(a)\t&#x2F;&#x2F; 24  切片组成元素：  指针：指向底层数组 长度：切片中元素的长度，不能大于容量 容量：指针所指向的底层数组的总容量"}</script><link rel="canonical" href="https://www.liangyouze.com/2020/10/11/golang%E5%88%87%E7%89%87/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="梁友泽的博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于我</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-11T07:10:23.000Z" title="10/11/2020, 3:10:23 PM">2020-10-11</time>发表</span><span class="level-item"><time dateTime="2025-01-02T13:37:12.450Z" title="1/2/2025, 9:37:12 PM">2025-01-02</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/golang/">golang</a></span><span class="level-item">33 分钟读完 (大约4960个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">golang 切片</h1><div class="content"><h3 id="切片结构"><a href="#切片结构" class="headerlink" title="切片结构"></a>切片结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">unsafe.Sizeof(a)	<span class="comment">// 24</span></span><br></pre></td></tr></table></figure>

<p>切片组成元素：</p>
<ul>
<li>指针：指向底层数组</li>
<li>长度：切片中元素的长度，不能大于容量</li>
<li>容量：指针所指向的底层数组的总容量 <span id="more"></span></li>
</ul>
<h3 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h3><ul>
<li>使用make<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)     <span class="comment">// 初始化长度和容量都为 5 的切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>) <span class="comment">// 初始化长度为 5, 容量为 10 的切片</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用 <code>make</code> 关键字创建切片时，很多工作都需要运行时的参与；调用方必须在 <code>make</code> 函数中传入一个切片的大小以及可选的容量，<code>[cmd/compile/internal/gc.typecheck1](https://github.com/golang/go/blob/b7d097a4cf6b8a9125e4770b54d33826fa803023/src/cmd/compile/internal/gc/typecheck.go#L327-L2126)</code> 会对参数进行校验：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="type">int</span>)</span></span> (res *Node) &#123;</span><br><span class="line">	<span class="keyword">switch</span> n.Op &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">case</span> OMAKE:</span><br><span class="line">		args := n.List.Slice()</span><br><span class="line"></span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		<span class="keyword">switch</span> t.Etype &#123;</span><br><span class="line">		<span class="keyword">case</span> TSLICE:</span><br><span class="line">			<span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				yyerror(<span class="string">&quot;missing len argument to make(%v)&quot;</span>, t)</span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			l = args[i]</span><br><span class="line">			i++</span><br><span class="line">			<span class="keyword">var</span> r *Node</span><br><span class="line">			<span class="keyword">if</span> i &lt; <span class="built_in">len</span>(args) &#123;</span><br><span class="line">				r = args[i]</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">			<span class="keyword">if</span> Isconst(l, CTINT) &amp;&amp; r != <span class="literal">nil</span> &amp;&amp; Isconst(r, CTINT) &amp;&amp; l.Val().U.(*Mpint).Cmp(r.Val().U.(*Mpint)) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				yyerror(<span class="string">&quot;len larger than cap in make(%v)&quot;</span>, t)</span><br><span class="line">				<span class="keyword">return</span> n</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			n.Left = l</span><br><span class="line">			n.Right = r</span><br><span class="line">			n.Op = OMAKESLICE</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数不仅会检查 <code>len</code> 是否传入，还会保证传入的容量 <code>cap</code> 一定大于或者等于 <code>len</code>，除了校验参数之外，当前函数会将 <code>OMAKE</code> 节点转换成 <code>OMAKESLICE</code>，随后的中间代码生成阶段在 <code>[cmd/compile/internal/gc.walkexpr](https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L439-L1532)</code> 函数中的 <code>[OMAKESLICE](https://github.com/golang/go/blob/4d5bb9c60905b162da8b767a8a133f6b4edcaa65/src/cmd/compile/internal/gc/walk.go#L1315)</code> 分支依据两个重要条件对这里的 <code>OMAKESLICE</code> 进行转换：</p>
<ol>
<li>切片的大小和容量是否足够小；</li>
<li>切片是否发生了逃逸，最终在堆上初始化</li>
</ol>
<p>虽然大多的错误都可以在编译期间被检查出来，但是在创建切片的过程中如果发生了以下错误就会直接导致程序触发运行时错误并崩溃：</p>
<ol>
<li>内存空间的大小发生了溢出；</li>
<li>申请的内存大于最大可分配的内存；</li>
<li>传入的长度小于 0 或者长度大于容量；</li>
</ol>
<p><code>[runtime.makeslice](https://draveness.me/golang/tree/runtime.makeslice)</code> 在最后调用的 <code>[runtime.mallocgc](https://draveness.me/golang/tree/runtime.mallocgc)</code> 是用于申请内存的函数，这个函数的实现比较复杂，如果遇到了比较小的对象会直接初始化在 Go 语言调度器里面的 P 结构中，而大于 32KB 的对象会在堆上初始化</p>
<ul>
<li><p>为啥是32kb </p>
<ul>
<li>界限的选择是基于一些性能和内存管理的考虑。</li>
<li>小于等于32KB的对象被认为是比较小的，可以在 P 结构中进行初始化。这样做有以下几个优点：<ul>
<li>减少对堆的访问：将对象初始化在 P 结构中可以避免频繁地访问堆，减少内存的分配和释放操作，提高程序的性能。</li>
<li>提高局部性：将对象与对应的 P 结构关联起来，可以提高数据的局部性，减少内存访问的延迟，进一步提升性能。</li>
</ul>
</li>
<li>大于32KB的对象被认为是较大的对象，其内存需求比较高。将这些对象直接初始化在堆上有以下几个优点：<ul>
<li>堆的管理更加灵活：堆提供了更加灵活的内存管理机制，可以根据需要动态分配和释放内存，适应各种大小的对象。</li>
<li>避免过度占用 P 结构：将大对象初始化在堆上可以避免过度占用 P 结构的内存空间，保持 P 结构的高效利用。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用简短定义</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>使用数组来初始化切片</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">slice := arr[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">// 左闭右开区间，最终切片为 [1,2,3]</span></span><br><span class="line"><span class="built_in">cap</span>(slice)  <span class="comment">// 长度为5,更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。注意，切片代表的窗口是无法向左扩展的。</span></span><br></pre></td></tr></table></figure>


<ul>
<li>使用切片来初始化切片<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sliceA := []int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">sliceB := sliceA[0:3] // 左闭右开区间，sliceB 最终为 [1,2,3]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="扩容例子"><a href="#扩容例子" class="headerlink" title="扩容例子"></a>扩容例子</h3><ul>
<li>注意点<ul>
<li>多个切片共享一个底层数组的情况，对底层数组的修改，将影响上层多个切片的值</li>
<li>多个切片共享一个底层数组的情况，对底层数组的修改，原有的切片发生了扩容 底层数组被重新创建 ，和原来的切片已经没有关系了</li>
<li><strong>扩容的slice还和类型(其实是类型占的字节)有关</strong></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">e := []<span class="type">int32</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap of e before:&quot;</span>,<span class="built_in">cap</span>(e))</span><br><span class="line">	e = <span class="built_in">append</span>(e,<span class="number">4</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap of e after:&quot;</span>,<span class="built_in">cap</span>(e))</span><br><span class="line"></span><br><span class="line">	f := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;cap of f before:&quot;</span>,<span class="built_in">cap</span>(f))</span><br><span class="line">	f = <span class="built_in">append</span>(f,<span class="number">4</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cap of f after:&quot;</span>,<span class="built_in">cap</span>(f))</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cap</span> of e before: <span class="number">3</span></span><br><span class="line"><span class="built_in">cap</span> of e after: <span class="number">8</span></span><br><span class="line"><span class="built_in">cap</span> of f before: <span class="number">3</span></span><br><span class="line"><span class="built_in">cap</span> of f after: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    newSlice := slice[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">    fmt.Println(<span class="string">&quot;before modifying underlying array:&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice: &quot;</span>, slice)</span><br><span class="line">    fmt.Println(<span class="string">&quot;newSlice: &quot;</span>, newSlice)</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    newSlice[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">    <span class="comment">// 如果是newSlice append几个元素进去，则slice的值为 6，1，2，3，4，5</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after modifying underlying array:&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice: &quot;</span>, slice)</span><br><span class="line">    fmt.Println(<span class="string">&quot;newSlice: &quot;</span>, newSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码预期输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before modify underlying array:</span><br><span class="line">slice:  [1 2 3 4 5]</span><br><span class="line">newSlice:  [1 2 3]</span><br><span class="line"></span><br><span class="line">after modify underlying array:</span><br><span class="line">slice:  [6 2 3 4 5]</span><br><span class="line">newSlice:  [6 2 3]</span><br></pre></td></tr></table></figure>

<p><strong>使用 copy 方法可以避免共享同一个底层数组</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">    newSlice := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(slice))</span><br><span class="line">    <span class="built_in">copy</span>(newSlice, slice)</span><br><span class="line">    fmt.Println(<span class="string">&quot;before modifying underlying array:&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice: &quot;</span>, slice)</span><br><span class="line">    fmt.Println(<span class="string">&quot;newSlice: &quot;</span>, newSlice)</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    newSlice[<span class="number">0</span>] = <span class="number">6</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;after modifying underlying array:&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;slice: &quot;</span>, slice)</span><br><span class="line">    fmt.Println(<span class="string">&quot;newSlice: &quot;</span>, newSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码预期输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">before modifying underlying array:</span><br><span class="line">slice:  [1 2 3 4 5]</span><br><span class="line">newSlice:  [1 2 3 4 5]</span><br><span class="line"></span><br><span class="line">after modifying underlying array:</span><br><span class="line">slice:  [1 2 3 4 5]</span><br><span class="line">newSlice:  [6 2 3 4 5]</span><br></pre></td></tr></table></figure>


<h3 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h3><p>通过 <code>append</code> 关键字被转换的控制流了解了在切片容量足够时如何向切片中追加元素，但是当切片的容量不足时就会调用 <code>[runtime.growslice](https://github.com/golang/go/blob/440f7d64048cd94cba669e16fe92137ce6b84073/src/runtime/slice.go#L76-L191)</code> 函数为切片扩容，扩容就是为切片分配一块新的内存空间并将原切片的元素全部拷贝过去，我们分几部分分析该方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">                newcap += newcap / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ……</span></span><br><span class="line"></span><br><span class="line">    capmem = roundupsize(<span class="type">uintptr</span>(newcap) * ptrSize)</span><br><span class="line">    newcap = <span class="type">int</span>(capmem / ptrSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后半部分还对 <code>newcap</code> 作了一个<code>内存对齐</code>，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 老 slice 容量的 <code>2倍</code>或者<code>1.25倍</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;len=%d, cap=%d&quot;</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>=<span class="number">5</span>, <span class="built_in">cap</span>=<span class="number">6</span> （如果按照<span class="number">1.25</span>倍的说法就是<span class="number">5</span>，<span class="number">8</span>，但实际上是错误的）</span><br></pre></td></tr></table></figure>

<p>这个函数的参数依次是 元素的类型，老的 slice，新 slice 最小求的容量。</p>
<p>例子中 s 原来只有 2 个元素，len 和 cap 都为 2，append 了三个元素后，长度变为 5，容量最小要变成 5，即调用 growslice 函数时，传入的第三个参数应该为 5。即 cap&#x3D;5。而一方面，doublecap 是原 slice容量的 2 倍，等于 4。满足第一个 if 条件，所以 newcap 变成了 5。 接着调用了 roundupsize 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）</p>
<p>再看内存对齐，搬出 roundupsize 函数的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">roundupsize</span><span class="params">(size <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> size &lt; _MaxSmallSize &#123;</span><br><span class="line">        <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">uintptr</span>(class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//……</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> _MaxSmallSize = <span class="number">32768</span></span><br><span class="line"><span class="keyword">const</span> smallSizeMax = <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> smallSizeDiv = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>最终返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_to_size[size_to_class8[(size+smallSizeDiv<span class="number">-1</span>)/smallSizeDiv]]</span><br></pre></td></tr></table></figure>

<p>这是 Go 源码中有关内存分配的两个 slice。class_to_size通过 spanClass获取 span划分的 object大小。而 size_to_class8 表示通过 size 获取它的 spanClass。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> size_to_class8 = [smallSizeMax/smallSizeDiv + <span class="number">1</span>]<span class="type">uint8</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> class_to_size = [_NumSizeClasses]<span class="type">uint16</span>&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>, <span class="number">144</span>, <span class="number">160</span>, <span class="number">176</span>, <span class="number">192</span>, <span class="number">208</span>, <span class="number">224</span>, <span class="number">240</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">352</span>, <span class="number">384</span>, <span class="number">416</span>, <span class="number">448</span>, <span class="number">480</span>, <span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span>, <span class="number">1152</span>, <span class="number">1280</span>, <span class="number">1408</span>, <span class="number">1536</span>, <span class="number">1792</span>, <span class="number">2048</span>, <span class="number">2304</span>, <span class="number">2688</span>, <span class="number">3072</span>, <span class="number">3200</span>, <span class="number">3456</span>, <span class="number">4096</span>, <span class="number">4864</span>, <span class="number">5376</span>, <span class="number">6144</span>, <span class="number">6528</span>, <span class="number">6784</span>, <span class="number">6912</span>, <span class="number">8192</span>, <span class="number">9472</span>, <span class="number">9728</span>, <span class="number">10240</span>, <span class="number">10880</span>, <span class="number">12288</span>, <span class="number">13568</span>, <span class="number">14336</span>, <span class="number">16384</span>, <span class="number">18432</span>, <span class="number">19072</span>, <span class="number">20480</span>, <span class="number">21760</span>, <span class="number">24576</span>, <span class="number">27264</span>, <span class="number">28672</span>, <span class="number">32768</span>&#125;</span><br></pre></td></tr></table></figure>

<p>传进去的 size 等于 40。所以 (size+smallSizeDiv-1)&#x2F;smallSizeDiv &#x3D; 5；获取 size_to_class8 数组中索引为 5 的元素为 4；获取 class_to_size 中索引为 4 的元素为 48。最终，新的 slice 的容量为 6：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newcap = <span class="type">int</span>(capmem / ptrSize) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>


<ol>
<li>预估容量（预估”元素个数”）</li>
</ol>
<p><img src="/img/images/go/%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9.png" alt="image.png"></p>
<p>注意：(<a target="_blank" rel="noopener" href="https://github.com/golang/go/commit/2333c6299f340a5f76a73a4fec6db23ffa388e97?branch=2333c6299f340a5f76a73a4fec6db23ffa388e97&diff=unified">官方代码</a>在2020-09-25 换成了 if old.cap &lt; 1024{} )</p>
<ul>
<li>如果新申请容量（cap）大于旧容量（old.cap）的两倍，则最终容量（newcap）是新申请的容量（cap）；</li>
<li>如果旧切片的长度小于 1024，则最终容量是旧容量的 2 倍，即“newcap&#x3D;doublecap”；  (注意1.18后时256)</li>
<li>如果旧切片的长度大于或等于 1024，则最终容量从旧容量开始循环增加原来的 1&#x2F;4，直到最终容量大于或等于新申请的容量为止；(注意1.18后时256，&gt;&#x3D;512)</li>
<li>如果最终容量计算值溢出，即超过了 int 的最大范围，则最终容量就是新申请容量。</li>
</ul>
<ol start="2">
<li>分配内存 &#x3D; 预估容量 * 元素类型大小</li>
</ol>
<p><strong>申请分配内存是语言自身实现的内存管理模块向操作系统申请(合适的内存规格:8,16,32,48,64,80,96,112……字节，64位下每个元素占16字节。32位下占8字节,其中查看类型占多少字节用unsafe.Sizeof()来判断，但是又如何得知当前平台是在处于多少为的系统。可以用以下来判断(比如int在64为下占8个字节，string在64为下占10个字节)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 &lt;&lt; (^uint(0) &gt;&gt; 63)</span><br></pre></td></tr></table></figure>

<p>^uint(0)在32位系统上返回的是0XFFFFFFFF, 也就是2^32, 在64位系统上返回的是0xFFFFFFFFFFFFFFFF, 也就是2^64</p>
<p>申请分配内存会匹配到最接近的规格</p>
<p>确认了最新容量后，则进行内存对齐。通过对元素的大小（et.size）的判断，对了内存对齐。通过数组class_to_size拿到对齐的值。</p>
<ol start="3">
<li>newCap &#x3D; 申请分配内存 &#x2F;  元素类型大小</li>
</ol>
<p>在1.22版本后切片的扩容机制变更为</p>
<ol>
<li>初始化变量：函数接受两个参数，newLen 表示切片的新长度，oldCap 表示切片的旧容量。开始时将 newcap 初始化为 oldCap。</li>
<li>判断是否需要直接扩容至新长度：首先计算 doublecap，即旧容量的两倍。如果新长度大于 doublecap，则直接返回新长度，因为此时直接扩容到新长度即可。</li>
<li>阈值判断：定义了一个阈值常量 threshold，其值为 256。如果旧容量小于该阈值，那么新容量直接设置为 doublecap。</li>
<li>循环计算新容量：对于大于等于阈值的旧容量，采用一种新的扩容策略，即每次增加 newcap 的 1.25 倍，直到 newcap 大于等于 newLen。</li>
<li>溢出检查：通过将 newcap 强制转换为 uint 类型进行溢出检查。如果 newcap 溢出，则直接返回新长度。</li>
<li>返回新容量：最后返回新容量，如果新容量小于等于 0，则返回新长度，以防溢出。</li>
</ol>
<p>这个机制在处理切片扩容时，尤其是针对大容量的切片，可以更加有效地管理内存，避免频繁的内存分配和拷贝操作，从而提高性能。</p>
<h3 id="拷贝切片"><a href="#拷贝切片" class="headerlink" title="拷贝切片"></a>拷贝切片</h3><p>当我们使用 <code>copy(a, b)</code> 的形式对切片进行拷贝时，编译期间的 <code>[cmd/compile/internal/gc.copyany](https://github.com/golang/go/blob/bf4990522263503a1219372cd8f1ee9422b51324/src/cmd/compile/internal/gc/walk.go#L2980-L3040)</code> 函数也会分两种情况进行处理，如果当前 <code>copy</code> 不是在运行时调用的，<code>copy(a, b)</code> 会被直接转换成下面的代码：</p>
<p>之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。<br>最后，向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="built_in">len</span>(b) &#123;</span><br><span class="line">    n = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> a.ptr != b.ptr &#123;</span><br><span class="line">    memmove(a.ptr, b.ptr, n*sizeof(elem(a))) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> sl []<span class="type">int</span> = arr[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> s2  []<span class="type">int</span> = arr[<span class="number">7</span>:]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sl),<span class="built_in">cap</span>(sl))  <span class="comment">// 3,9 </span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s2),<span class="built_in">cap</span>(s2))  <span class="comment">// 3,3</span></span><br></pre></td></tr></table></figure>

<p> 一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。注意，切片代表的窗口是无法向左扩展的。(前面提到的)</p>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a[:len(a)-1]   // 删除尾部1个元素</span><br><span class="line">a = a[:len(a)-N]   // 删除尾部N个元素</span><br><span class="line">a = a[1:] // 删除开头1个元素</span><br><span class="line">a = a[N:] // 删除开头N个元素</span><br><span class="line">a = append(a[:i], a[j:]...)  // cut  i ~ j </span><br></pre></td></tr></table></figure>


<p>假设切片里存放的是指针对象，那么下面删除末尾的元素后，被删除的元素依然被切片底层数组引用，从而导致被自动垃圾回收器回收（这要依赖回收器的实现方式）：</p>
<p>保险的方式是先将需要自动内存回收的元素设置为<code>nil</code>，保证自动回收器可以发现需要回收的对象，然后再进行切片的删除操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a []*int&#123; ... &#125;</span><br><span class="line">a[len(a)-1] = nil // GC回收最后一个元素内存</span><br><span class="line">a = a[:len(a)-1]  // 从切片删除最后一个元素</span><br></pre></td></tr></table></figure>

<p>同理<br>截掉切片[i,j）之间的元素：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">append</span>(a[:i], a[j:]...)</span><br></pre></td></tr></table></figure>
<p>上面的Cut如果元素是指针的话，会存在内存泄露，所以我们要对删除的元素设置nil，等待GC。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(a[i:], a[j:])</span><br><span class="line"><span class="keyword">for</span> k, n := <span class="built_in">len</span>(a)-j+i, <span class="built_in">len</span>(a); k &lt; n; k++ &#123;</span><br><span class="line"> a[k] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">&#125;</span><br><span class="line">a = a[:<span class="built_in">len</span>(a)-j+i]</span><br></pre></td></tr></table></figure>

<p>Delete（GC）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(a[i:], a[i+<span class="number">1</span>:])</span><br><span class="line">a[<span class="built_in">len</span>(a)<span class="number">-1</span>] = <span class="literal">nil</span> <span class="comment">// or the zero value of T</span></span><br><span class="line">a = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>切片使用不当对内存的泄露</p>
<ol>
<li>应该将原切片拷到一个新的切片操作，比如使用切片的前5个slice<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMessageType</span><span class="params">(msg []<span class="type">byte</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	msgType := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="built_in">copy</span>(msgType, msg)</span><br><span class="line">	<span class="keyword">return</span> msgType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>分组切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chunk</span><span class="params">(actions []<span class="type">int</span>, batchSize <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> batches [][]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> batchSize &lt; <span class="built_in">len</span>(actions) &#123;</span><br><span class="line">    	actions, batches = actions[batchSize:], <span class="built_in">append</span>(batches, actions[<span class="number">0</span>:batchSize:batchSize])</span><br><span class="line">	&#125;</span><br><span class="line">	batches = <span class="built_in">append</span>(batches, actions)</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">return</span> batches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时数组可以作为 map 的 k（键），而切片不行</p>
<ul>
<li><p>它的大小和类型在编译时就已经确定了。</p>
</li>
<li><p>append函数的常见操作</p>
<ul>
<li>删除位于索引 i 的元素：a &#x3D; append(a[:i], a[i+1:]…)</li>
<li>切除切片 a 中从索引 i 至 j 位置的元素：a &#x3D; append(a[:i], a[j:]…)</li>
<li>为切片 a 扩展 j 个元素长度：a &#x3D; append(a, make([]T, j)…)</li>
<li>索引 i 的位置插入切片 b 的所有元素：a &#x3D; append(a[:i], append(b, a[i:]…)…)</li>
</ul>
</li>
</ul>
<h3 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h3><p><strong>slice 是非协程安全的数据类型，如果创建多个 goroutine 对 slice 进行并发读写，会造成丢失</strong>。看一段代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            a = <span class="built_in">append</span>(a, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 9403 9876 9985 9491 ...</span></span><br></pre></td></tr></table></figure>

<p>多次执行，每次得到的结果都不一样，总之一定不会是想要的 10000 个。想要解决这个问题，按照协程安全的编程思想来考虑问题<br>可以考虑使用 channel 本身的特性(阻塞)来实现安全的并发读写。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    buffer := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> v := <span class="keyword">range</span> buffer &#123;</span><br><span class="line">            a = <span class="built_in">append</span>(a, v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            buffer &lt;- i</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(a))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10000</span></span><br></pre></td></tr></table></figure>

<h3 id="slice-坑"><a href="#slice-坑" class="headerlink" title="slice 坑"></a>slice 坑</h3><p>bar 执行了 append 函数之后，最终也修改了 foo 的最后一个元素，这是一个在实践中非常常见的陷阱。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">42</span>, <span class="number">100</span>&#125;</span><br><span class="line">bar := foo[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">bar = <span class="built_in">append</span>(bar, <span class="number">99</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;foo:&quot;</span>, foo) <span class="comment">// foo: [0 0 0 42 99]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;bar:&quot;</span>, bar) <span class="comment">// bar: [0 0 42 99]</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/images/go/image1.png" alt="image.png"></p>
<p>bar 的 cap 容量会到原始切片的末尾，所以当前 bar 的 cap 长度为 4。</p>
<p>如果要解决这样的问题，其实可以在截取时指定容量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">42</span>,<span class="number">100</span>&#125;</span><br><span class="line">bar := foo[<span class="number">1</span>:<span class="number">4</span>:<span class="number">4</span>]</span><br><span class="line">bar = <span class="built_in">append</span>(bar, <span class="number">99</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;foo:&quot;</span>, foo) <span class="comment">// foo: [0 0 0 42 100]</span></span><br><span class="line">fmt.Println(<span class="string">&quot;bar:&quot;</span>, bar) <span class="comment">// bar: [0 0 42 99]</span></span><br></pre></td></tr></table></figure>

<p>foo[1:4:4] 这里，第三个参数 4 代表 cap 的位置一直到下标 4，但是不包括下标 4。 所以当前 bar 的 Cap 变为了 3，和它的长度相同。当 bar 进行 append 操作时，将发生扩容，它会指向与 foo 不同的底层数据空间。由于bar的容量足够，它将继续使用foo的底层数数组，所以foo也被修改成了[0, 0, 0, 42, 99]。</p>
<h3 id="切片中的三种特殊状态"><a href="#切片中的三种特殊状态" class="headerlink" title="切片中的三种特殊状态"></a>切片中的三种特殊状态</h3><p>切片的三种特殊状态 —— 「零切片」、「空切片」和「nil 切片」。</p>
<p><img src="/img/images/go/image2.png" alt="image.png"></p>
<p>空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。</p>
<p>不管是使用 nil 切片还是空切片，对其调用内置函数 append，len 和 cap 的效果都是一样的。</p>
<p>通过 unsafe.Pointer 来转换 Go 语言的任意变量类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s3 = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">var</span> s4 = *<span class="built_in">new</span>([]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s1))</span><br><span class="line"><span class="keyword">var</span> a2 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s2))</span><br><span class="line"><span class="keyword">var</span> a3 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s3))</span><br><span class="line"><span class="keyword">var</span> a4 = *(*[<span class="number">3</span>]<span class="type">int</span>)(unsafe.Pointer(&amp;s4))</span><br><span class="line">fmt.Println(a1)</span><br><span class="line">fmt.Println(a2)</span><br><span class="line">fmt.Println(a3)</span><br><span class="line">fmt.Println(a4)</span><br><span class="line"></span><br><span class="line">---------------------</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">824634355296</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">824634355296</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>其中输出为 [0 0 0] 的 s1 和 s4 变量就是「 nil 切片」，s2 和 s3 变量就是「空切片」。824634199592 这个值是一个特殊的内存地址，所有类型的「空切片」都共享这一个内存地址。<br><img src="/img/images/go/image3.png" alt="image.png"></p>
<p>空切片指向的 zerobase 内存地址是一个神奇的地址</p>
<p>「 nil 切片」和 「空切片」在使用上有什么区别么？</p>
<p>最好办法是不要创建「 空切片」，统一使用「 nil 切片」，同时要避免将切片和 nil 进行比较来执行某些逻辑。这是官方的标准建议。（正确选择 var res []int ）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var s1 []int      // nil 切片</span><br><span class="line">	var s2 = []int&#123;&#125; // 空切片</span><br><span class="line"></span><br><span class="line">	fmt.Println(s1 == nil)</span><br><span class="line">	fmt.Println(s2 == nil)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%#v\n&quot;, s1)</span><br><span class="line">	fmt.Printf(&quot;%#v\n&quot;, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">[]int(nil)</span><br><span class="line">[]int&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>「空切片」和「 nil 切片」有时候会隐藏在结构体中，这时候它们的区别就被太多的人忽略了，看个例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Something <span class="keyword">struct</span> &#123;</span><br><span class="line">	values []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 = Something&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> s2 = Something&#123;[]<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">fmt.Println(s1.values == <span class="literal">nil</span>)</span><br><span class="line">fmt.Println(s2.values == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>「空切片」和「 nil 切片」还有一个极为不同的地方在于 JSON 序列化</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Something struct &#123;</span><br><span class="line">	Values []int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s1 = Something&#123;&#125;</span><br><span class="line">var s2 = Something&#123;[]int&#123;&#125;&#125;</span><br><span class="line">bs1, _ := json.Marshal(s1)</span><br><span class="line">bs2, _ := json.Marshal(s2)</span><br><span class="line">fmt.Println(string(bs1))</span><br><span class="line">fmt.Println(string(bs2))</span><br><span class="line"></span><br><span class="line">---------</span><br><span class="line">&#123;&quot;Values&quot;:null&#125;</span><br><span class="line">&#123;&quot;Values&quot;:[]&#125;</span><br></pre></td></tr></table></figure>

<p>注意，对于切片的判断最好使用len()&#x3D;&#x3D;0</p>
<p>参考</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/36393806/why-go-vet-report-uint0-might-be-too-small-for-shift-of-63">why-go-vet-report-uint0-might-be-too-small-for-shift-of-63</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CV411d7W8">slice类型存什么？make和new？slice和数组？扩容规则？</a></li>
<li><a target="_blank" rel="noopener" href="https://geektutu.com/post/hpg-slice.html">切片(slice)性能及陷阱</a></li>
<li><a target="_blank" rel="noopener" href="https://qcrao91.gitbook.io/go/shu-zu-he-qie-pian/qie-pian-de-rong-liang-shi-zen-yang-zeng-chang-de">切片的容量是怎样增长的</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">3.2 切片</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903712654098446">深度解析 Go 语言中「切片」的三种特殊状态</a></li>
</ol>
</div><div class="article-licensing box"><div class="licensing-title"><p>golang 切片</p><p><a href="https://www.liangyouze.com/2020/10/11/golang切片/">https://www.liangyouze.com/2020/10/11/golang切片/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>梁友泽</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-10-11</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-01-02</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/golang/">golang</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/images/qrcode/Alipay.jpeg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/images/qrcode/WeChat.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/01/2020%E5%B9%B4%E6%80%BB%E7%BB%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">2020年总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/08/11/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"><span class="level-item">内存对齐</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="梁友泽"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">梁友泽</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">55</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">20</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/youzeliang" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/youzeliang"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.liangyongrui.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">梁永锐</span></span><span class="level-right"><span class="level-item tag">www.liangyongrui.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/azure/"><span class="level-start"><span class="level-item">azure</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/gin/"><span class="level-start"><span class="level-item">gin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/golang/"><span class="level-start"><span class="level-item">golang</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/kafka/"><span class="level-start"><span class="level-item">kafka</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/map/"><span class="level-start"><span class="level-item">map</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/panic/"><span class="level-start"><span class="level-item">panic</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/string/"><span class="level-start"><span class="level-item">string</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/vim/"><span class="level-start"><span class="level-item">vim</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/"><span class="level-start"><span class="level-item">内存逃逸</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%87%BD%E6%95%B0/"><span class="level-start"><span class="level-item">函数</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8F%8D%E5%B0%84/"><span class="level-start"><span class="level-item">反射</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%88%E7%8E%87/"><span class="level-start"><span class="level-item">效率</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%A7%84%E8%8C%83/"><span class="level-start"><span class="level-item">规范</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-20T13:10:23.000Z">2025-03-20</time></p><p class="title"><a href="/2025/03/20/AI%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%EF%BC%9AAzure%E4%B8%8ELLVM%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81%E5%8A%A0%E9%80%9F%E6%96%B9%E6%A1%88/">AI驱动的编译器优化：Azure与LLVM的自动化代码加速方案</a></p><p class="categories"><a href="/categories/azure/">azure</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-03-15T13:10:23.000Z">2025-03-15</time></p><p class="title"><a href="/2025/03/15/Blackwell%20Ultra%20GPU%E5%9C%A8Azure%20AI%E4%B8%AD%E7%9A%84%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B%EF%BC%9A%E4%B8%87%E4%BA%BF%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/">Blackwell Ultra GPU在Azure AI中的未来展望：万亿参数模型训练</a></p><p class="categories"><a href="/categories/azure/">azure</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-27T12:10:23.000Z">2025-02-27</time></p><p class="title"><a href="/2025/02/27/zure%E4%B8%8ENVIDIA%20Megatron%E7%9A%84%E5%8D%8F%E5%90%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">zure与NVIDIA Megatron的协同优化方案</a></p><p class="categories"><a href="/categories/azure/">azure</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-19T13:10:23.000Z">2025-02-19</time></p><p class="title"><a href="/2025/02/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E9%AB%98%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E5%8F%8A%E5%85%B6%E5%9C%A8%20Azure%20%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/">深入理解高可扩展性及其在 Azure 中的实现</a></p><p class="categories"><a href="/categories/azure/">azure</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-02-12T13:10:23.000Z">2025-02-12</time></p><p class="title"><a href="/2025/02/12/Azure%E6%97%A0%E6%9C%8D%E5%8A%A1%E5%99%A8GPU%E5%AE%9E%E6%88%98%EF%BC%9A%E4%BD%8E%E6%88%90%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%A4%9A%E6%A8%A1%E6%80%81%E5%A4%A7%E6%A8%A1%E5%9E%8B/">Azure无服务器GPU实战：低成本运行多模态大模型</a></p><p class="categories"><a href="/categories/azure/">azure</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/05/"><span class="level-start"><span class="level-item">五月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">五月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">四月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/09/"><span class="level-start"><span class="level-item">九月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/azure/"><span class="tag">azure</span><span class="tag">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/context/"><span class="tag">context</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/elasticsearch/"><span class="tag">elasticsearch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iframe/"><span class="tag">iframe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kafka/"><span class="tag">kafka</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vim/"><span class="tag">vim</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%AA%E4%BA%BA/"><span class="tag">个人</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"><span class="tag">内存对齐</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"><span class="tag">字符串</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B4%A2%E5%BC%95/"><span class="tag">索引</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%A7%84%E5%88%99/"><span class="tag">规则</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A2%E5%8D%95%E5%8F%B7/"><span class="tag">订单号</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6/"><span class="tag">读书</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%A8%E5%9F%9F/"><span class="tag">跨域</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="梁友泽的博客" height="28"></a><p class="is-size-7"><span>&copy; 2025 梁友泽</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "Este sitio web utiliza cookies para mejorar su experiencia.",
          dismiss: "¡Entendido!",
          allow: "Permitir cookies",
          deny: "Descenso",
          link: "Aprende más",
          policy: "Política de cookies",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>